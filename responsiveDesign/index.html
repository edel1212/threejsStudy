<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        html, body {
           margin: 0;
           height: 100%;
        }
        #c {
           width: 100%;
           height: 100%;
           /* blockì„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ì—¬ë°±ì´ ìƒê¹€ */
           display: block;
        }
        </style>
</head>
<body>
    <canvas id="c"></canvas>

    <script type="module">
        "use strict";
        import * as THREE from 'https://unpkg.com/three/build/three.module.js';
        
        // scene
        const scene = new THREE.Scene();
        
        // camera
        const camera = new THREE.PerspectiveCamera(75,2, 0.1, 10);
        camera.position.z = 2;

        // renderer
        const renderer = new THREE.WebGLRenderer({canvas : document.querySelector("#c"),antialias : true});

        // ëª¨ì–‘ ì •ì˜ - Three.jsì—ì„œ í‘œì‹œí•˜ë ¤ëŠ” ê±°ì˜ ëª¨ë“  ê²ƒì€ 3Dê°œì²´ë¥¼ êµ¬ì„±í•˜ëŠ” ì •ì ì„ ì •ì˜í•´ ì¤˜ì•¼í•¨ [ğŸ‘‰ë¬¼ì²´ì˜ ëª¨ì–‘]
        const geometry = new THREE.BoxGeometry(1, 1, 1);
 
        // íë¸Œ ë°°ì—´ ìƒì„±
        const cubes = [ makeInstance(geometry, 0x44aa88,  0), makeInstance(geometry, 0x8844aa, -2), makeInstance(geometry, 0xaa8844,  2) ];

        // ì¡°ëª… ì¶”ê°€
        const light = new THREE.DirectionalLight(0xFFFFFF, 1);
        light.position.set(-1,2,4);   // ì¡°ëª… ìœ„ì¹˜ ì„¤ì •
        scene.add(light);             // ì¥ë©´ì— ì¡°ëª… ì¶”ê°€

        // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ ì¶”ê°€
        function animationFunc(time){
            time *= 0.001;

            cubes.forEach((cube, ndx) => {
                const speed = 1 + ndx * .1;
                const rot = time * speed;
                cube.rotation.x = rot;
                cube.rotation.y = rot;
            });
            
            /**
             * í™”ë©´ì„ ì¤„ì—¬ë„ í•´ë‹¹ í™”ë©´ì— ëª¨ë“ ê²ƒì´ ë‚˜ì˜¤ëŠ”ê²ƒì´ ì•„ë‹Œ
             * í˜„ì¬ ë¹„ìœ¨ì— ë§ì¶°ì„œ ë³´ì´ê²Œë”í•¨
             * ex) 
             *     ğŸ’¬ ì ìš© ì „
             *     ã… ã… ã…  << ì „ì²´í™”ë©´ ë‹¤ë³´ì„
             *     ã… ã… ã…  << í™”ë©´ì„ ì£½ì—¬ë„ ì°Œê·¸ëŸ¬ì ¸ì„œ ë‹¤ë³´ì„
             * 
             *     ğŸ’¬ ì ìš© í›„
             *     ã… ã… ã…  << ì „ì²´í™”ë©´ ë‹¤ë³´ì„
             *        ã…    << ê°€ìš´ë°ë§Œ ë³´ì„ ì¤‘ê°„ìœ¼ë¡œ ì¡í˜
            */
            // ğŸ‘‰ ëœëŸ¬ë”©ì¤‘ì¸ ìº”ë²„ìŠ¤ë¥¼ ì°¾ìŒ
            if(resizeRendererToDisplaySize(renderer)){
                const canvas = renderer.domElement;
                // ì „ì œì¡°ê±´ì€ canvasì˜ cssê°€ '%'ì—¬ì•¼ í•¨ ê·¸ë˜ì•¼ ì½ì§€!
                camera.aspect = canvas.clientWidth/ canvas.clientHeight;
                // ì ìš©ëœ ì¹´ë©”ë¼ ì˜µì…˜ì„ ì—…ë°ì´íŠ¸!
                camera.updateProjectionMatrix();
            }

            renderer.render(scene, camera);

            requestAnimationFrame(animationFunc);
        }
        animationFunc(20);
        
        /**
         * íë·° ìƒì„± ì¸ìŠ¤í„´ìŠ¤
         * @param BoxGeometry   geomerty 
         *        String        color
         *        int           x 
         * @return Mesh
        */
         function  makeInstance(geomerty, color , x){
            const meterial = new THREE.MeshPhongMaterial({color});
            const cube = new THREE.Mesh(geomerty, meterial);
            scene.add(cube);
            cube.position.x = x;
            return cube;
        }

        /**
         * í™”ë©´ì˜ í¬ê¸°ì— ë§ì¶°ì„œ ë„í˜•ì„ ëœë”ë§ í• ìˆ˜ìˆê²Œí•¨
         * - ğŸ‘‰ cssë¡œ ì˜ˆë¥¼ ë“¤ë©´ 120x120 ì´ë¯¸ì§€ë¥¼ width:500ìœ¼ë¡œ ì¡°ì •í•˜ë©´ 
         *      ì´ìƒì—†ì´ ê·¸ë ¤ì§€ë‚˜ í”½ì…€ì´ ê¹¨ì§€ëŠ”ê±°ì™€ ë¹„ìŠ·í•œ ê°œë…
         * @param WebGLRenderer renderer
         * @return boolean
        */
        function resizeRendererToDisplaySize(renderer){
            // canvasë¥¼ ì°¾ìŒ
            const canvas = renderer.domElement;
            // ë¯¸ì„¸í•œ í™”ì§ˆ ì¡°ì •ì„ ìœ„í•¨
            const pixelRatio = window.devicePixelRatio;
            const width  = canvas.clientWidth  * pixelRatio || 0;
            const height = canvas.clientHeight * pixelRatio || 0;
            const needResize = canvas.width !== width  || canvas.height !== height;            
            // ë§ˆì§€ë§‰ ì¸ìëŠ” cssë„ ê°™ì´ updateí• ì§€ ì—¬ë¶€
            if(needResize) renderer.setSize(width, height, false);
            return needResize;
        }

    </script>

</body>
</html>